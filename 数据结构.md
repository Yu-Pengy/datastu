## 考试经验

一道题也就30min时间

要先耐心设计再代码实现

一天练一点额外题目吧孩子

运行时错误为数组索引溢出导致

只错少数数据点可能是对于特殊情况的处理错误导致

大片错误一定是代码写错了

`vscode Ctrl + k,Ctrl + f`自动格式化代码

字符串的子串必须是连续的几个字符

## 数据的读入与写出

```c++
#include<fstream>
vector<int> readnumbers(const string& filename,int n) {
	ifstream file(filename);
	vector<int>numbers;
	int num;
	for (int i = 0; i < n && file >> num; i++) {
		numbers.push_back(num);
	}
	file.close();
	return numbers;
}
```

文件读取方面，

不加const无法读取临时变量

file >>num按单词读取

`getline(file,line)`

文件读取：

```(空)
#include<sstream>
#include<fstream>
ifstream file("in.txt");
string line1, line2;
getline(file,line1);//读取第一行
istringstream iss(line1);//字符串转为输入流对象
int num;
while(iss >> num){
	nums.push_back(num);
}
getline(file,line2);
target = stoi(line2);
file.close();//string to integer
```

文件读取：

1 ABCBCA

```(空)
 int num; // 存储第一个数字
    vector<char> chars; // 存储剩下的字母

    // 读取第一个数字
    file >> num;

    // 跳过空白字符
    file.ignore(); 

    // 逐个读取字母
    char c;
    while (file.get(c)) {
        if (isalpha(c)) { // 检查是否是字母
            chars.push_back(c);
        }
    }

    // 关闭文件
    file.close();
```

对于不限定数量的数据的读取

```(空)
#include<sstream>//使用stringstream
#include<string> //使用getline(cin,line);line是一个字符串getline第三个参数默认是'\n'
//大体操作
string line1;
getline(cin, line1);
stringstream ss(line1);
int num;
while(ss >> num){
	chuli
}
```

特殊情况

```(空)
int num;
cin >> num;
getline(cin,line1);
在getline前有个cin,导致getline读到空行，解决方式
int num;
cin>> num;
cin.ignore();
getline;l
```

第二方案

```(空)
while(cin >> num){
	if(cin.peek() == '\n'){
		break;
	}
}
```

存在问题，如果输入的数的后一位有空格，那么不行，必须就是最后一个数直接换行

第三方案，和第二方案类似

```(空)
while(cin >> num){
	if(getchar() == '\n'){
		break;
	}
}
```

向文件中写入

```(空)
#include<fstream>
ofstream ofs("output.txt");
for(int num : data){
	ofs << num << " ";
}
ofs.close();
```

利用`getline`读取==用逗号分隔==的数据

```(空)
getline(file,ss,',');//第三个参数默认为'\n'，可以修改
```

对数字的读取==为了防止两位数被读成一位数==

不能用*char*来存数据，char会把21读成2，要用*string*

把string改为int，stoi函数实现

对输入流的新理解

```(空)
#include<iostream>  //就像cin一样读取数据就行
#include<string>
#include<sstream>
using namespace std;
int main() {
	string name;
	int num;
	string line;
	getline(cin, line);
	stringstream ss(line);
    ss >> name;
	ss >> num;
	cout << "name = " << name << " " << "num = " << num;
	return 0;
}
```



## 具体算法的实现

不要忘记调整数组，链表元素数量时，改变size

隐含漏洞：`nums.size()`返回unsigned int 用int去循环可能爆int

```(空)
vector<int> twoSum(vector<int>& nums, int target)
{
	unordered_map<int, int>memo;
	for (int i = 0; i < nums.size(); i++) {
		if (memo.count(target - nums[i])) {
			return { memo[target - nums[i]], i };
		}
		memo[nums[i]] = i;
	}
	return { -1, -1 };
}//用哈希表来解决两数字的和的问题，时间复杂度低
```

找交集，==排序且去重==，两个指针，相同添加，不同，数值小的增加，大的不变，有一个结束就结束

找差集，相等，同时加加，不等，值小的是差集

找并集

```(空)
while (i < 5 && j < 5) {//类似这样的思路
	if (arr1[i] < arr2[j]) {
		arr3.push_back(arr1[i]);
		i++;
		
	}
	else if (arr1[i] == arr2[j]) {
		arr3.push_back(arr1[i]);
		i++;
		j++;
	}
	else if (arr1[i] > arr2[j]) {
		arr3.push_back(arr2[j]);
		j++;
	}
	size++;
}
if (i == 5) {
	for (int k = j; k < 5; k++) {
		arr3.push_back(arr2[k]);
		size++;
	}
}
else if (j == 5) {
	for (int k = i; k < 5; k++) {
		arr3.push_back(arr1[k]);
		size++;
	}
}
```

去除指定元素，双指针,==不需要排序或去重==，可以记录不等于x的尾巴，去赋值，也可以区间划分，去交换，划分不等于x的区间和等于x的区间，

二路归并，==不去重地放在一起==

`LIstNode::next will be initialized after[-Wreorder]`构造函数初始化顺序和类中声明顺序一致，不然就报

链表逆序，采用把头结点和后续结点切断，然后把后续结点采用头插法查到新链表里，注意保存

```(空)
temp = head->next;
head->next = NULL
ListNode *p;
while(temp){
	p = temp->next;
	temp->next = head;
	head = temp;
	temp = temp->next;//错误temp->next已经被赋值为head了
	temp = p;//正确
	//temp = temp->next;
}
```

```(空)
LinkNode* curr = head;
if (size == 0) {
    curr = newNode;
}//不会影响head的值，是错误的操作
```

## 期中考试反思总结

第一题：退格问题

运行时错误为栈数组下溢导致，因为这个随机产生空格的实际问题可能会退格比字母数多，如果不==在退格时对栈是否为空进行特判==，就会导致错误

经验：1）**运行时错误的原因**：数组溢出

​	   2）**对可能溢出的队列和栈进行特判**

第二题：求链表交集

早上新犯的问题：

```(空)
ListNode* newNode = new ListNode(num);
tail1 = newNode;//直接就把原链表切断了
tail1 = tail1->next;
```

建表方法

```(空)
#include<iostream>
#include<string>
#include<sstream>
using namespace std;
struct ListNode {
	int data;
	ListNode* next;
	ListNode():next(NULL){}
	ListNode(int x):data(x),next(NULL){}
};
int main() {
	ListNode dummy;
	ListNode* head1 = &dummy;//哑结点法
	string line1, line2;
	getline(cin, line1);
	stringstream ss(line1);
	int num;
	ListNode* q = head1;//不能让head1移动
	while (ss >> num) {
		ListNode* newNode = new ListNode(num);
		q->next = newNode;
		q = q->next;
	}
	head1 = head1->next;
	while (head1) { 
		cout << head1->data << " ";
		head1 = head1->next;
	}
}
```

==NULL连接不了下一个结点，必须用一个实际的结点来连接下一个结点==

==head必须有地址==

**重要总结（关于头节点的问题）：**1）如果用类实现，可以加上元素个数的判断，如果没有元素和有元素用不同的处理方式，保证头节点非空，或者如果带头节点的，要写默认构造函数给头节点赋一个地址，绝对不能==NULL->next==解引用空指针，2）如果不用类实现链表，那就要带上头节点，并且把头节点用哑对象法赋值，`ListNode curra;ListNode*head = &curra;`让头节点非空，然后用`ListNode *q = head;q->next = ~~`做事。3）如果是尾插，把头节点置空就好了

==NULL是使指针不指向有效地址，避免野指针的产生，不能解引用或使用==

```(空)
//解决求有序链表交集并倒序的代码，直接建表，用一个记录尾巴结点的指针配合建表
#include<iostream>
#include<string>
#include<sstream>
using namespace std;
struct ListNode {
	int data;
	ListNode* next;
	ListNode():next(NULL){}
	ListNode(int x):data(x),next(NULL){}
};
int main() {
	ListNode cummy1,cummy2;
	ListNode* head1 = &cummy1;//哑结点法
	ListNode* head2 = &cummy2;
	string line1, line2;
	getline(cin, line1);
	stringstream ss(line1);
	int num;
	ListNode* q = head1;//不能让head1移动
	while (ss >> num) {//不统计数量的情况下一定需要首结点
		ListNode* newNode = new ListNode(num);
		q ->next = newNode;
		q = q->next;
	}
	getline(cin, line2);
	stringstream sss(line2);
	q = head2;
	while (sss >> num) {
		ListNode* newNode = new ListNode(num);
		q->next = newNode;
		q = q->next;
	}
	ListNode cummy3;
	ListNode* head3 = NULL;
	head1 = head1->next;
	head2 = head2->next;
	while (head1 && head2) {
		if (head1->data == head2->data) {
			ListNode* newNode = new ListNode(head1->data);
			newNode->next = head3;
			head3 = newNode;
			head1 = head1->next;
			head2 = head2->next;
		}
		else if (head1->data < head2->data) head1 = head1->next;
		else head2 = head2->next;
	}
	while (head3) {
		cout << head3->data << " ";
		head3 = head3->next;
	}
}
```

第三题：用vector实现循环队列

==不是哥们，队列出队你动什么尾指针啊，我哩个逗啊==

不小心把一个判断写成=====，导致每次都被执行，气死了

## 算法学习

### 广度优先搜索

**解决问题：**最短路问题，连通性问题

顶点访问：如果队列不为空，弹出一个队首元素u，继续访问和u相邻的顶点v，如果v不在哈希表中，则在哈希表中标记掉v，并且把v插入到队列中。直到队列为空，搜索结束。

```(空)
function bfs(n,s,edges[maxn],visited){
	q = Queue()//初始化过程
	visited.clear()
	q.push(s)
	visited.add(s)
	while(not q.empty())//搜索
		u = q.front()
		q.pop()
		for i -> (0,edges[u].size() - 1)
			v = edges[u][i]
			if(v not in visited)
				q.push(v)
				visited.add(v)
}
```

细节剖析：确界最短路，并且终点已经确定，访问到终点可以直接返回；有多个起点，开始时都插进来；邻接表的边有权值，算法改进为Dijkstra + 堆优化 或者 SPFA

```(空)
struct Node {
	int x;
	int y;
	int fatheridx;
}queue[20];//用数组模拟队列，方便找前一个结点
```

## 知识点

### ‘sort’函数的使用

`sort(first,last,compare);``compare(a,b)`如果返回true，把a排在b前

`sort(vec.begin(),vec.end(),[](int a,int b){return a > b})`lambda表达式

```(空)
bool compareDescending(int a, int b) {
    return a > b; // 降序
}
sort(vec.begin(), vec.end(), compareDescending);
#include <functional> // 引入 std::greater
sort(vec.begin(), vec.end(), greater<int>());
```

==对自定义对象排序：==

可以通过重载<运算符或提供自定义比较器

```(空)
struct Person {
    std::string name;
    int age;

    // 重载 < 运算符（默认升序）
    bool operator<(const Person& other) const {
        return age < other.age;
    }
};
sort(people.begin(), people.end());
//使用lambda表达式
std::sort(people.begin(), people.end(), [](const Person& a, const Person& b) {
        return a.name > b.name;
    });
```

```c++
//排序对象是结构体数组
struct task{
    int arrival;
    int execution;
}tasks[51];
bool compare(const task& a, const task& b) {//注意康康这里
    if (a.arrival == b.arrival) {
        return false;  // If arrival times are the same, maintain original order
    }
    return a.arrival < b.arrival;  // Otherwise, sort by arrival time
}
```



## 刷题心得

HDU4393 throw nails

![](../Pictures/Screenshots/屏幕截图 2025-04-08 092135.png)

注意到n为10的四次方级，如果硬遍历n方logn的复杂度无法接受，注意到si比较小，所以用si来建立优先队列数组，实现题目

```(空)
#include<iostream>
#include<algorithm>
#include<queue>
using namespace std;
struct node{
  	int fi;
	int id;
    bool operator<(const node &a)const{
        if(fi==a.fi)
            return id>a.id;
        else
            return fi<a.fi;
    }
};
priority_queue<node>q[105];
int main(){
    ios::sync_with_stdio(false);//关闭cin和sacnf的同步，省一些时间
    int T;
    int cas=1;
    cin>>T;
    while(T--){
        int n;
        cin>>n;
        cout<<"Case #"<<cas++<<":"<<endl;
        for(int i=1;i<=n;i++){
            int a,b;
            node p;
            cin>>a>>b;
            p.fi=a;
            p.id=i;
            q[b].push(p);
        }
        for(int i=0;i<n;i++){        //n既代表选手数,也代表当前时间
            int pos,pid,max=-1;
            for(int j=1;j<101;j++){     //遍历q数组
                if(!q[j].empty()){
                    node p=q[j].top();
                    if(p.fi+j*i>max||(p.fi+j*i==max&&p.id<pid)){
                        pos=j;
                        pid=p.id;
                        max=p.fi+j*i;
                    }
                }
            }
            if(i!=n-1)
            	cout<<pid<<" ";
            else
                cout<<pid;
            q[pos].pop();
        }
        cout<<endl;
    }
    return 0;
}
```

## 递归

**1.数据结构是递归的**

单链表就是一种递归的数据结构，对于递归的数据结构，编写递归算法方便又有效

```c++
int Sum(ListNode<int>* p){
	if(p == NULL) return 0;
	return p->data + Sum(p->next);
}
```

**2.定义是递归的**

**3.问题的求解方法是递归的**

```c++
//汉诺塔问题
Hanoi(n-1,x,z,y);
move(n,x,z);
Hanoi(n-1,y,x,z);
```

==注意递归出口的设置==

“递” & “归” 把大问题拆解为小问题

时间复杂度，以汉诺塔问题为例

`T(n) = 2T(n - 1) + 1`等于两个小问题的时间加上一个简单移动的时间1

`S(n) = S(n - 1) + 1`这里的空间主要指栈空间，解决完一个小问题后栈空间会被释放重复利用，所以S前不是2而是1

递归，伪递归可以用循环或者栈转换为非递归

递归两种思路：大问题分解为小问题，遍历的思想

## 树和二叉树

### 树

非线性结构，分为顺序存储结构和链式存储结构

定义是递归的，用到了子树的概念

书中某个结点的子树个数称为结点的度，**各结点度的最大值称为树的度**，将度为m的树称为m次数树或m叉树

树根节点在第一层，树中结点的最大层次称为**树的高度（深度）**

树的存储结构：

**1.双亲存储结构**

是一种顺序存储结构，借助顺序表

```c++
struct PNode{//双亲存储结构的元素类型
    char data;
  	int parent;//存放双亲索引
    PNode(char d,int p){
        data = d;
        parent = p;
    }
};
```

**2.孩子链存储结构**

==每个结点包含指向所有孩子结点的指针==

```c++
struct SonNode{
  	char data;
    vector<SonNode*>sons;
    SonNode(){}
    SonNode(char d):data(d){}
};
```

![](../Pictures/图片/E0A5B79FBF8214E3CAEEC979C3EF98E8.jpg)

其中sons向量为空的是叶子结点

**3.长子兄弟链存储结构**

```c++
struct EBNode{
  	char data;
    EBNode* brother;//指向兄弟
    EBNode* eson;//指向长子结点
    EBNode():brother(NULL),eson(NULL){}
    EBNode(char d){
        data = d;
        brother = eson = NULL;
    }
};
```

### 二叉树

与树是两种不同的树形结构，没有至少有一个结点度为2的要求，度为1的结点要==*严格区分左右子树*==，

递归算法设计很看重一种==根，左，右==的思维

